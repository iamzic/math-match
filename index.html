<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Match!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <!-- Add Supabase JS Client -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f0f9ff; /* Light blue background */
            color: #0f172a; /* Slate 900 */
        }
        .btn {
            padding-left: 1.5rem;
            padding-right: 1.5rem;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            transition-property: transform;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        .btn:hover {
            transform: scale(1.05);
        }
        .btn:focus {
            outline: none;
            --tw-ring-offset-width: 2px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / 0.5);
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
        .btn-primary {
            background-color: rgb(14 165 233);
            color: white;
        }
        .btn-primary:hover {
            background-color: rgb(2 132 199);
        }
        .btn-primary:focus {
            --tw-ring-color: rgb(56 189 248);
        }
        .btn-secondary {
            background-color: rgb(16 185 129);
            color: white;
        }
        .btn-secondary:hover {
            background-color: rgb(5 150 105);
        }
        .btn-secondary:focus {
            --tw-ring-color: rgb(52 211 153);
        }
        .btn-accent {
            background-color: rgb(245 158 11);
            color: white;
        }
        .btn-accent:hover {
            background-color: rgb(217 119 6);
        }
        .btn-accent:focus {
            --tw-ring-color: rgb(251 191 36);
        }
        .btn-danger {
            background-color: rgb(239 68 68);
            color: white;
        }
        .btn-danger:hover {
            background-color: rgb(220 38 38);
        }
        .btn-danger:focus {
            --tw-ring-color: rgb(248 113 113);
        }
        .card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1);
        }
        .input-field {
            margin-top: 0.25rem;
            display: block;
            width: 100%;
            padding-left: 1rem;
            padding-right: 1rem;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            border: 1px solid rgb(203 213 225);
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        }
        .input-field:focus {
            --tw-ring-color: rgb(14 165 233);
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
            border-color: rgb(14 165 233);
        }
        .player-avatar {
            font-size: 1.875rem;
        }
        .question-text {
            font-size: 1.5rem;
            font-weight: 700;
            color: rgb(51 65 85);
            margin-top: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .option-btn {
            width: 100%;
            font-size: 1.125rem;
            padding-left: 1rem;
            padding-right: 1rem;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            margin: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            transition-property: transform;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        .option-btn:hover {
            transform: scale(1.05);
        }
        .option-btn:focus {
            outline: none;
            --tw-ring-offset-width: 2px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(203 213 225);
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
        .option-btn-default {
            background-color: rgb(226 232 240);
            color: rgb(51 65 85);
        }
        .option-btn-default:hover {
            background-color: rgb(203 213 225);
        }
        .option-btn-correct {
            background-color: rgb(34 197 94) !important;
            color: white !important;
        }
        .option-btn-correct:hover {
            background-color: rgb(22 163 74) !important;
        }
        .option-btn-correct:focus {
            --tw-ring-color: rgb(74 222 128) !important;
        }
        .option-btn-wrong {
            background-color: rgb(248 113 113) !important;
            color: white !important;
        }
        .option-btn-wrong:hover {
            background-color: rgb(239 68 68) !important;
        }
        .option-btn-wrong:focus {
            --tw-ring-color: rgb(251 113 133) !important;
        }
        .disabled-btn {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #message-modal {
            position: fixed;
            inset: 0;
            background-color: rgb(0 0 0 / 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            transition-property: opacity;
            transition-duration: 300ms;
            z-index: 100;
        }
        #message-modal.visible {
            display: flex;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
            text-align: center;
            max-width: 24rem;
            width: 100%;
        }
        .hidden {
            display: none;
        }
        /* Fun animal background pattern (subtle) */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23bae6fd' fill-opacity='0.3'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.5;
            z-index: -1;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div id="loading-indicator" class="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50 pointer-events-none">
        <div class="text-sky-600 text-xl font-semibold">
            <svg class="animate-spin h-8 w-8 text-sky-500 mr-3 inline-block" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading Math Adventure...
        </div>
    </div>

    <div id="app-container" class="w-full max-w-2xl mx-auto hidden">
        <header class="my-6 text-center">
            <h1 class="text-4xl sm:text-5xl font-bold text-sky-600">Math Match! 🚀</h1>
            <p id="user-id-display" class="mt-2 text-sm text-slate-500">Your User ID: <span class="font-semibold"></span></p>
        </header>

        <section id="lobby-section" class="card">
            <h2 class="text-2xl font-bold text-center text-emerald-600 mb-6">Join the Fun!</h2>
            <div class="space-y-4">
                <div>
                    <label for="player-name" class="block text-sm font-medium text-slate-700">Your Nickname:</label>
                    <input type="text" id="player-name" class="input-field" placeholder="Super Kid">
                </div>
                <button id="create-game-btn" class="btn btn-primary w-full">Create New Game 🌟</button>
                <div class="mt-6 pt-6 border-t border-slate-200">
                    <label for="game-id-input" class="block text-sm font-medium text-slate-700">Enter Game ID to Join:</label>
                    <div class="flex space-x-2 mt-1">
                        <input type="text" id="game-id-input" class="input-field flex-grow" placeholder="Game ID from a friend">
                        <button id="join-game-btn" class="btn btn-secondary">Join Game</button>
                    </div>
                </div>
            </div>
        </section>

        <section id="game-room-section" class="card hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-sky-600">Game Room</h2>
                <p class="text-sm text-slate-500">Game ID: <strong id="display-game-id" class="text-sky-700"></strong></p>
            </div>
            
            <div id="waiting-area" class="mb-6 text-center">
                <p id="waiting-message" class="text-slate-600 text-lg mb-4">Waiting for players... Share the Game ID!</p>
                <div id="player-list-lobby" class="space-y-2">
                    </div>
                <button id="start-game-btn" class="btn btn-primary mt-6 hidden">Start Game Now! 🎉</button>
            </div>

            <div id="game-active-area" class="hidden">
                <div id="question-area" class="mb-6">
                    <p id="round-display" class="text-center text-md font-semibold text-amber-600 mb-2"></p>
                    <p id="question-text" class="question-text">Question will appear here...</p>
                    <div id="options-container" class="flex flex-wrap justify-center items-center mt-4">
                        </div>
                </div>

                <div id="game-message-area" class="text-center my-4 min-h-[2em]">
                    <p id="game-message" class="text-lg font-semibold"></p>
                </div>
                
                <div class="text-center mt-6">
                     <button id="next-question-btn" class="btn btn-accent hidden">Next Question ➡️</button>
                </div>
            </div>
            
            <div id="scoreboard" class="mt-8 pt-6 border-t border-slate-200">
                <h3 class="text-xl font-bold text-center text-emerald-600 mb-4">Scoreboard 🏆</h3>
                <div id="player-scores" class="space-y-3">
                    </div>
            </div>

            <div id="game-over-area" class="hidden text-center mt-8">
                <h2 id="game-over-title" class="text-3xl font-bold text-sky-600 mb-4">Game Over!</h2>
                <p id="winner-message" class="text-xl text-emerald-600 font-semibold mb-6"></p>
                <button id="play-again-btn" class="btn btn-primary">Play Again?</button>
            </div>
             <button id="leave-game-btn" class="btn btn-danger mt-8 w-full">Leave Game</button>
        </section>
    </div>

    <div id="message-modal" class="hidden">
        <div class="modal-content">
            <p id="modal-text" class="text-xl font-semibold mb-4"></p>
            <button id="modal-close-btn" class="btn btn-primary">OK</button>
        </div>
    </div>

    <script type="module">
        // Import configuration
        import config from './config.js';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(config.supabaseUrl, config.supabaseKey);

        // DOM Elements
        const loadingIndicator = document.getElementById('loading-indicator');
        const appContainer = document.getElementById('app-container');
        const userIdDisplay = document.getElementById('user-id-display').querySelector('span');
        
        const lobbySection = document.getElementById('lobby-section');
        const playerNameInput = document.getElementById('player-name');
        const createGameBtn = document.getElementById('create-game-btn');
        const gameIdInput = document.getElementById('game-id-input');
        const joinGameBtn = document.getElementById('join-game-btn');

        const gameRoomSection = document.getElementById('game-room-section');
        const displayGameId = document.getElementById('display-game-id');
        const waitingArea = document.getElementById('waiting-area');
        const waitingMessage = document.getElementById('waiting-message');
        const playerListLobby = document.getElementById('player-list-lobby');
        const startGameBtn = document.getElementById('start-game-btn');
        
        const gameActiveArea = document.getElementById('game-active-area');
        const roundDisplay = document.getElementById('round-display');
        const questionTextEl = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const gameMessageArea = document.getElementById('game-message-area');
        const gameMessage = document.getElementById('game-message');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        
        const scoreboard = document.getElementById('scoreboard');
        const playerScoresEl = document.getElementById('player-scores');
        const gameOverArea = document.getElementById('game-over-area');
        const gameOverTitle = document.getElementById('game-over-title');
        const winnerMessage = document.getElementById('winner-message');
        const playAgainBtn = document.getElementById('play-again-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');

        const messageModal = document.getElementById('message-modal');
        const modalText = document.getElementById('modal-text');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // Game State
        let currentUser = null;
        let currentUserId = null;
        let currentGameId = null;
        let currentGameData = null;
        let gameSubscription = null;
        const MAX_ROUNDS = 5;
        const AVATARS = ['🥳', '🤩', '🤯', '🤓', '🤠', '👽', '🤖', '👻', '👑', '🎈', '⭐', '🍉', '🍓', '🦄', '🐲', '🦊', '🐻', '🐼', '🐸', '��'];

        // --- Modal Functions ---
        function showModal(text, autoCloseDelay = null) {
            modalText.textContent = text;
            messageModal.classList.add('visible');
            messageModal.style.opacity = '1';

            if (autoCloseDelay) {
                setTimeout(hideModal, autoCloseDelay);
            }
        }

        function hideModal() {
            messageModal.style.opacity = '0';
            setTimeout(() => {
                messageModal.classList.remove('visible');
            }, 300); // Match transition duration
        }
        modalCloseBtn.addEventListener('click', hideModal);

        // --- Authentication ---
        async function initializeAuth() {
            try {
                // Generate a unique anonymous user ID
                const uniqueId = `anon_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                const uniqueEmail = `${uniqueId}@anonymous.mathdash.com`;
                const uniquePassword = `pass_${Math.random().toString(36).substring(2, 12)}`;

                // Try to sign up with unique credentials
                const { data: { user }, error: signUpError } = await supabase.auth.signUp({
                    email: uniqueEmail,
                    password: uniquePassword,
                    options: {
                        data: {
                            is_guest: true,
                            unique_id: uniqueId
                        }
                    }
                });

                if (signUpError) {
                    // If sign up fails, try to sign in
                    const { data: { user: existingUser }, error: signInError } = await supabase.auth.signInWithPassword({
                        email: uniqueEmail,
                        password: uniquePassword
                    });

                    if (signInError) {
                        // If both sign up and sign in fail, try one more time with a different unique ID
                        const retryId = `anon_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                        const retryEmail = `${retryId}@anonymous.mathdash.com`;
                        const retryPassword = `pass_${Math.random().toString(36).substring(2, 12)}`;

                        const { data: { user: finalUser }, error: finalError } = await supabase.auth.signUp({
                            email: retryEmail,
                            password: retryPassword,
                            options: {
                                data: {
                                    is_guest: true,
                                    unique_id: retryId
                                }
                            }
                        });

                        if (finalError) throw finalError;
                        return finalUser;
                    }

                    return existingUser;
                }

                return user;
            } catch (error) {
                console.error("Error during authentication:", error);
                showModal(`Authentication Error: ${error.message}`);
                return null;
            }
        }

        // --- Game Logic ---
        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function getPlayerName() {
            return playerNameInput.value.trim() || `Player_${currentUserId.substring(0,4)}`;
        }
        
        function getRandomAvatar() {
            return AVATARS[Math.floor(Math.random() * AVATARS.length)];
        }

        async function createGame() {
            if (!currentUserId) {
                showModal("You must be logged in to create a game.");
                return;
            }
            const gameId = generateGameId();
            currentGameId = gameId;
            const hostPlayerName = getPlayerName();
            const hostAvatar = getRandomAvatar();

            const initialGameData = {
                game_id: gameId,
                host_id: currentUserId,
                status: "lobby",
                players: {
                    [currentUserId]: {
                        name: hostPlayerName,
                        avatar: hostAvatar,
                        score: 0,
                        isHost: true,
                        joined_at: new Date().toISOString(),
                        unique_id: currentUser.user_metadata.unique_id
                    }
                },
                current_question: null,
                question_start_time: null,
                last_winner: null,
                message: `${hostPlayerName} created the game! Waiting for players...`,
                round: 0,
                max_rounds: MAX_ROUNDS,
                created_at: new Date().toISOString(),
                question_answered_by: {}
            };

            try {
                const { error } = await supabase
                    .from('math_games')
                    .insert([initialGameData]);

                if (error) throw error;

                showModal(`Game ${gameId} created! Share this ID with friends.`, 3000);
                switchToGameRoom(gameId, initialGameData);
            } catch (error) {
                console.error("Error creating game:", error);
                showModal(`Error creating game: ${error.message}`);
                currentGameId = null;
            }
        }

        async function joinGame() {
            if (!currentUserId) {
                showModal("You must be logged in to join a game.");
                return;
            }
            const gameId = gameIdInput.value.trim().toUpperCase();
            if (!gameId) {
                showModal("Please enter a Game ID.");
                return;
            }

            try {
                const { data: game, error } = await supabase
                    .from('math_games')
                    .select('*')
                    .eq('game_id', gameId)
                    .single();

                if (error) throw error;
                if (!game) {
                    showModal("Game not found. Check the ID and try again.");
                    return;
                }

                if (game.status !== "lobby") {
                    showModal("This game has already started or finished.");
                    return;
                }

                // Check if player is already in the game
                if (game.players[currentUserId]) {
                    showModal("You are already in this game.");
                    return;
                }

                const playerName = getPlayerName();
                const playerAvatar = getRandomAvatar();

                const updatedPlayers = {
                    ...game.players,
                    [currentUserId]: {
                        name: playerName,
                        avatar: playerAvatar,
                        score: 0,
                        isHost: false,
                        joined_at: new Date().toISOString(),
                        unique_id: currentUser.user_metadata.unique_id
                    }
                };

                const { error: updateError } = await supabase
                    .from('math_games')
                    .update({
                        players: updatedPlayers,
                        message: `${playerName} joined the game!`
                    })
                    .eq('game_id', gameId);

                if (updateError) throw updateError;

                currentGameId = gameId;
                switchToGameRoom(gameId, { ...game, players: updatedPlayers });
            } catch (error) {
                console.error("Error joining game:", error);
                showModal(`Error joining game: ${error.message}`);
            }
        }
        
        async function leaveGame() {
            if (!currentUserId || !currentGameId) {
                showModal("Not in a game or not logged in.");
                return;
            }

            try {
                const { error: deleteError } = await supabase
                    .from('math_games')
                    .delete()
                    .eq('game_id', currentGameId);

                if (deleteError) throw deleteError;

                showModal("You have left the game.", 2000);
            } catch (error) {
                console.error("Error leaving game:", error);
                showModal(`Error leaving game: ${error.message}`);
            } finally {
                switchToLobby();
            }
        }

        function switchToLobby() {
            if (gameSubscription) {
                gameSubscription.unsubscribe();
            }
            currentGameId = null;
            currentGameData = null;

            lobbySection.classList.remove('hidden');
            gameRoomSection.classList.add('hidden');
            gameOverArea.classList.add('hidden');
            gameActiveArea.classList.add('hidden');
            waitingArea.classList.remove('hidden'); // Show waiting area by default when switching to game room view
            startGameBtn.classList.add('hidden');
            nextQuestionBtn.classList.add('hidden');
            gameIdInput.value = ''; // Clear input
        }

        function switchToGameRoom(gameId, initialGameData = null) {
            lobbySection.classList.add('hidden');
            gameRoomSection.classList.remove('hidden');
            displayGameId.textContent = gameId;

            if (gameSubscription) {
                gameSubscription.unsubscribe();
            }

            gameSubscription = supabase
                .channel(`game-${gameId}`)
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'math_games',
                    filter: `game_id=eq.${gameId}`
                }, async (payload) => {
                    let gameData = payload.new;
                    if (!gameData) {
                        // Fallback: fetch latest game data if payload.new is undefined
                        const { data, error } = await supabase
                            .from('math_games')
                            .select('*')
                            .eq('game_id', gameId)
                            .single();
                        if (error) {
                            console.error('Failed to fetch latest game data:', error);
                            return;
                        }
                        gameData = data;
                    }
                    currentGameData = gameData;
                    updateGameUI(currentGameData);
                })
                .subscribe();

            if (initialGameData) {
                updateGameUI(initialGameData);
            }
        }

        function updateGameUI(gameData) {
            if (!currentUserId || !gameData) return; // Ensure user and game data are available
            
            // Update player list in lobby and scoreboard
            updatePlayerLists(gameData.players);
            gameMessage.textContent = gameData.message || "";

            if (gameData.status === "lobby") {
                waitingArea.classList.remove('hidden');
                gameActiveArea.classList.add('hidden');
                gameOverArea.classList.add('hidden');
                waitingMessage.textContent = gameData.message || "Waiting for players...";
                if (gameData.host_id === currentUserId && Object.keys(gameData.players).length >= 1) { // Min 1 player to start
                    startGameBtn.classList.remove('hidden');
                } else {
                    startGameBtn.classList.add('hidden');
                }
            } else if (gameData.status === "active") {
                waitingArea.classList.add('hidden');
                gameActiveArea.classList.remove('hidden');
                gameOverArea.classList.add('hidden');
                startGameBtn.classList.add('hidden');
                
                roundDisplay.textContent = `Round ${gameData.round} of ${gameData.max_rounds}`;

                if (gameData.current_question) {
                    displayQuestion(gameData.current_question, gameData.question_answered_by || {});
                } else {
                    questionTextEl.textContent = "Waiting for the host to start the next question...";
                    optionsContainer.innerHTML = "";
                }

                // Show Next Question button for host if:
                // 1. All players have answered, OR
                // 2. Time limit has been reached (20 seconds), OR
                // 3. Someone has won the round
                const allPlayersAnswered = Object.keys(gameData.question_answered_by || {}).length === Object.keys(gameData.players).length;
                const timeLimitReached = gameData.question_start_time && (Date.now() - new Date(gameData.question_start_time).getTime() > 20000);
                const roundWinner = gameData.last_winner;

                if (gameData.host_id === currentUserId && gameData.current_question && (allPlayersAnswered || timeLimitReached || roundWinner)) {
                    nextQuestionBtn.classList.remove('hidden');
                } else {
                    nextQuestionBtn.classList.add('hidden');
                }

            } else if (gameData.status === "finished") {
                waitingArea.classList.add('hidden');
                gameActiveArea.classList.add('hidden');
                gameOverArea.classList.remove('hidden');
                nextQuestionBtn.classList.add('hidden');
                startGameBtn.classList.add('hidden');

                const winnerInfo = determineWinner(gameData.players);
                if (winnerInfo) {
                    winnerMessage.textContent = `${winnerInfo.name} wins with ${winnerInfo.score} points! Congratulations!`;
                } else {
                    winnerMessage.textContent = "It's a tie or no scores recorded!";
                }
                if (gameData.host_id === currentUserId) {
                    playAgainBtn.textContent = "Restart Game";
                } else {
                    playAgainBtn.textContent = "Back to Lobby";
                }
            }
        }

        function updatePlayerLists(players) {
            playerListLobby.innerHTML = '';
            playerScoresEl.innerHTML = '';
            if (!players) return;

            // Convert players object to array and sort by score
            const playersArray = Object.entries(players).map(([id, player]) => ({
                id,
                ...player
            })).sort((a, b) => b.score - a.score);

            playersArray.forEach(player => {
                // Lobby List
                const playerLobbyItem = document.createElement('div');
                playerLobbyItem.className = 'flex items-center space-x-2 p-2 bg-slate-100 rounded-md';
                playerLobbyItem.innerHTML = `
                    <span class="player-avatar">${player.avatar}</span>
                    <span class="font-semibold ${player.id === currentUserId ? 'text-sky-600' : 'text-slate-700'}">${player.name} ${player.isHost ? '(Host 👑)' : ''}</span>
                `;
                playerListLobby.appendChild(playerLobbyItem);

                // Scoreboard
                const playerScoreItem = document.createElement('div');
                playerScoreItem.className = 'flex justify-between items-center p-3 bg-white rounded-lg shadow';
                playerScoreItem.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <span class="player-avatar">${player.avatar}</span>
                        <span class="font-medium ${player.id === currentUserId ? 'text-sky-700' : 'text-slate-800'}">${player.name} ${player.isHost ? '👑' : ''}</span>
                    </div>
                    <span class="text-xl font-bold text-emerald-500">${player.score || 0} pts</span>
                `;
                playerScoresEl.appendChild(playerScoreItem);
            });
        }

        async function startGame() {
            if (!currentUserId || !currentGameId || !currentGameData || currentGameData.host_id !== currentUserId) {
                showModal("Only the host can start the game.");
                return;
            }
            try {
                const firstQuestion = generateMathQuestion();
                await supabase
                    .from('math_games')
                    .update({
                        status: "active",
                        round: 1,
                        current_question: firstQuestion,
                        question_start_time: new Date().toISOString(),
                        message: "Game started! First question:",
                        last_winner: null,
                        question_answered_by: {}
                    })
                    .eq('game_id', currentGameId);
            } catch (error) {
                console.error("Error starting game:", error);
                showModal(`Error starting game: ${error.message}`);
            }
        }
        
        function generateMathQuestion() {
            const type = Math.random() < 0.6 ? 'addition' : 'counting'; // 60% addition, 40% counting
            let questionText = '';
            let options = [];
            let correctAnswer;

            if (type === 'addition') {
                const num1 = Math.floor(Math.random() * 5) + 1; // 1-5
                const num2 = Math.floor(Math.random() * 5) + 1; // 1-5
                correctAnswer = num1 + num2;
                questionText = `What is ${num1} + ${num2}?`;
                
                options.push({ text: correctAnswer.toString(), correct: true });
                while (options.length < 3) { // Generate 2 wrong answers
                    let wrongAnswer = Math.floor(Math.random() * 10) + 1; // 1-10
                    if (wrongAnswer !== correctAnswer && !options.find(opt => opt.text === wrongAnswer.toString())) {
                        options.push({ text: wrongAnswer.toString(), correct: false });
                    }
                }
            } else { // counting
                const count = Math.floor(Math.random() * 5) + 1; // 1-5
                const objects = ['🍎', '🍌', '⭐', '⚽', '🚗', '🧸', '🎈'];
                const object = objects[Math.floor(Math.random() * objects.length)];
                questionText = `How many ${object} are there? ${Array(count).fill(object).join(' ')}`;
                correctAnswer = count;

                options.push({ text: correctAnswer.toString(), correct: true });
                 while (options.length < 3) {
                    let wrongAnswer = Math.floor(Math.random() * 7) + 1; // 1-7 for counting
                    if (wrongAnswer !== correctAnswer && !options.find(opt => opt.text === wrongAnswer.toString())) {
                        options.push({ text: wrongAnswer.toString(), correct: false });
                    }
                }
            }
            // Shuffle options
            options.sort(() => Math.random() - 0.5);
            return { id: `q-${Date.now()}`, text: questionText, options: options, type: type };
        }

        function displayQuestion(question, answeredBy) {
            questionTextEl.textContent = question.text;
            optionsContainer.innerHTML = '';
            const playerAnswer = answeredBy[currentUserId];

            question.options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option.text;
                button.classList.add('option-btn', 'option-btn-default');
                
                if (playerAnswer) {
                    button.classList.add('disabled-btn');
                    button.disabled = true;
                    
                    // If this is the player's selected answer
                    if (playerAnswer.selectedOption === option.text) {
                        button.classList.remove('option-btn-default');
                        button.classList.add(playerAnswer.correct ? 'option-btn-correct' : 'option-btn-wrong');
                    }
                    
                    // If this is the correct answer and player has answered
                    if (option.correct && Object.keys(answeredBy).length > 0) {
                        button.classList.remove('option-btn-default');
                        button.classList.add('option-btn-correct');
                    }
                } else {
                    button.onclick = () => submitAnswer(option);
                }
                optionsContainer.appendChild(button);
            });
        }

        async function submitAnswer(selectedOption) {
            if (!currentUserId || !currentGameId || !currentGameData || !currentGameData.current_question) return;
            
            // Prevent answering if already answered this question or if round winner decided
            if (currentGameData.question_answered_by[currentUserId] || currentGameData.last_winner) {
                showModal("This question has already been answered or someone won the round.", 2000);
                return;
            }

            try {
                // Get the current game data to update the question_answered_by object
                const { data: game, error: fetchError } = await supabase
                    .from('math_games')
                    .select('*')
                    .eq('game_id', currentGameId)
                    .single();

                if (fetchError) throw fetchError;

                // Check if the answer is correct
                const isCorrect = selectedOption.correct;
                const updatedPlayers = { ...game.players };
                
                // Update player's score if answer is correct
                if (isCorrect) {
                    const currentPlayer = updatedPlayers[currentUserId];
                    updatedPlayers[currentUserId] = {
                        ...currentPlayer,
                        score: (currentPlayer.score || 0) + 1
                    };
                }

                // Create updated question_answered_by object
                const updatedAnsweredBy = {
                    ...(game.question_answered_by || {}),
                    [currentUserId]: {
                        answered: true,
                        correct: isCorrect,
                        selectedOption: selectedOption.text
                    }
                };

                // Update the game with the new question_answered_by object and player scores
                const { error: updateError } = await supabase
                    .from('math_games')
                    .update({
                        question_answered_by: updatedAnsweredBy,
                        players: updatedPlayers,
                        message: `${currentGameData.players[currentUserId].name} answered ${isCorrect ? 'correctly' : 'incorrectly'}.`
                    })
                    .eq('game_id', currentGameId);

                if (updateError) throw updateError;

                // After submitting, re-render options to disable them and show feedback
                if (currentGameData && currentGameData.current_question) {
                    displayQuestion(currentGameData.current_question, updatedAnsweredBy);
                }

            } catch (error) {
                console.error("Error submitting answer:", error);
                showModal(`Error submitting answer: ${error.message}`);
            }
        }

        async function nextQuestion() {
            if (!currentUserId || !currentGameId || !currentGameData || currentGameData.host_id !== currentUserId) {
                showModal("Only the host can start the next question.");
                return;
            }

            const nextRound = currentGameData.round + 1;
            if (nextRound > currentGameData.max_rounds) {
                // Game Over
                try {
                    await supabase
                        .from('math_games')
                        .update({
                            status: "finished",
                            message: "Game Over! Calculating scores...",
                            current_question: null,
                            last_winner: null,
                            question_answered_by: {}
                        })
                        .eq('game_id', currentGameId);
                } catch (error) {
                    console.error("Error finishing game:", error);
                    showModal(`Error finishing game: ${error.message}`);
                }
            } else {
                // Next Round
                const newQuestion = generateMathQuestion();
                try {
                    await supabase
                        .from('math_games')
                        .update({
                            round: nextRound,
                            current_question: newQuestion,
                            question_start_time: new Date().toISOString(),
                            message: `Round ${nextRound}! Here's the new question:`,
                            last_winner: null,
                            question_answered_by: {}
                        })
                        .eq('game_id', currentGameId);
                } catch (error) {
                    console.error("Error loading next question:", error);
                    showModal(`Error loading next question: ${error.message}`);
                }
            }
        }
        
        function determineWinner(players) {
            if (!players || Object.keys(players).length === 0) return null;
            let highScore = -1;
            let winners = [];
            for (const id in players) {
                if (players[id].score > highScore) {
                    highScore = players[id].score;
                    winners = [players[id]];
                } else if (players[id].score === highScore) {
                    winners.push(players[id]);
                }
            }
            if (winners.length === 1) return winners[0];
            if (winners.length > 1) return { name: "It's a tie between " + winners.map(w => w.name).join(', '), score: highScore };
            return null;
        }

        async function handlePlayAgain() {
             if (!currentUserId || !currentGameId || !currentGameData) return;

            if (currentGameData.host_id === currentUserId) { // Host can restart
                // Reset game state for a new game with same players
                const newPlayersState = {};
                Object.keys(currentGameData.players).forEach(pid => {
                    newPlayersState[pid] = { ...currentGameData.players[pid], score: 0 };
                });
                const firstQuestion = generateMathQuestion();
                try {
                    await supabase
                        .from('math_games')
                        .update({
                            status: "active", // Or "lobby" if want to wait for players again
                            round: 1,
                            current_question: firstQuestion,
                            question_start_time: new Date().toISOString(),
                            message: "New game started by the host!",
                            last_winner: null,
                            question_answered_by: {},
                            players: newPlayersState
                        })
                        .eq('game_id', currentGameId);
                } catch (error) {
                     console.error("Error restarting game:", error);
                     showModal(`Error restarting game: ${error.message}`);
                }
            } else { // Non-hosts go back to lobby
                switchToLobby();
            }
        }

        // Event Listeners
        createGameBtn.addEventListener('click', () => {
            console.log('Create game button clicked');
            createGame();
        });
        joinGameBtn.addEventListener('click', () => {
            console.log('Join game button clicked');
            joinGame();
        });
        startGameBtn.addEventListener('click', () => {
            console.log('Start game button clicked');
            startGame();
        });
        nextQuestionBtn.addEventListener('click', () => {
            console.log('Next question button clicked');
            nextQuestion();
        });
        playAgainBtn.addEventListener('click', () => {
            console.log('Play again button clicked');
            handlePlayAgain();
        });
        leaveGameBtn.addEventListener('click', () => {
            console.log('Leave game button clicked');
            leaveGame();
        });
        
        // Initialize Auth on load
        initializeAuth().then(user => {
            if (user) {
                currentUser = user;
                currentUserId = user.id;
                userIdDisplay.textContent = currentUserId;
                playerNameInput.placeholder = `Player_${currentUserId.substring(0, 4)}`;
                if (!playerNameInput.value) {
                    playerNameInput.value = AVATARS[Math.floor(Math.random() * AVATARS.length)] + ` Kid_${currentUserId.substring(0,3)}`;
                }
            } else {
                currentUser = null;
                currentUserId = null;
                userIdDisplay.textContent = "Not logged in";
                showModal("You are not logged in. Please refresh the page.");
                lobbySection.classList.add('hidden');
            }
            loadingIndicator.style.display = 'none';
            appContainer.style.display = 'block';
        }).catch(err => {
            console.error("Initialization Auth Error:", err);
            showModal("Could not initialize authentication. Please refresh.");
            loadingIndicator.style.display = 'none';
            appContainer.style.display = 'block';
        });

        // Make sure to clean up on page unload (optional but good practice)
        window.addEventListener('beforeunload', async () => {
            // This is tricky with anonymous users or if they just close tab.
            // A more robust solution for presence needs cloud functions or more complex client-side heartbeats.
            // For now, if a user is in a game and is the host, and they are the only one, the game might be auto-deleted on next join attempt or via a cleanup function.
            // The leaveGame function has logic to handle host leaving and game deletion if empty.
            if (currentUserId && currentGameId && currentGameData && currentGameData.players[currentUserId]) {
                 // A simple attempt to mark player as 'left' or remove them.
                 // However, `leaveGame()` is more robust and should be triggered by a button.
                 // Automatic removal on tab close is unreliable.
                //these options need to be added.
            }
            if (gameSubscription) {
                gameSubscription.unsubscribe();
            }
        });

    </script>
</body>
</html>
